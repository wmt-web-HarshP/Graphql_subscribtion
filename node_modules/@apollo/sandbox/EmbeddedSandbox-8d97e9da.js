import MIMEType from 'whatwg-mimetype';
import { Observable } from 'zen-observable-ts';
import EventEmitter from 'eventemitter3';
import { createClient } from 'graphql-ws';
import { SubscriptionClient as SubscriptionClient$1 } from 'subscriptions-transport-ws';

const EMBEDDABLE_SANDBOX_URL = (__testLocal__ = false) => __testLocal__ ? 'https://embed.apollo.local:3000/sandbox/explorer' : 'https://sandbox.embed.apollographql.com/sandbox/explorer'; // Message types for Explorer state
const SCHEMA_ERROR = 'SchemaError';
const SCHEMA_RESPONSE = 'SchemaResponse'; // Message types for queries and mutations

const EXPLORER_QUERY_MUTATION_REQUEST = 'ExplorerRequest';
const EXPLORER_QUERY_MUTATION_RESPONSE = 'ExplorerResponse';

const EXPLORER_SUBSCRIPTION_REQUEST = 'ExplorerSubscriptionRequest';
const EXPLORER_SUBSCRIPTION_RESPONSE = 'ExplorerSubscriptionResponse';
const EXPLORER_SUBSCRIPTION_TERMINATION = 'ExplorerSubscriptionTermination';
const EXPLORER_SET_SOCKET_ERROR = 'ExplorerSetSocketError';
const EXPLORER_SET_SOCKET_STATUS = 'ExplorerSetSocketStatus';
const IFRAME_DOM_ID = uniqueId => `apollo-embed-${uniqueId}`; // Message types for authentication

const EXPLORER_LISTENING_FOR_HANDSHAKE = 'ExplorerListeningForHandshake';
const HANDSHAKE_RESPONSE = 'HandshakeResponse';
const SET_PARTIAL_AUTHENTICATION_TOKEN_FOR_PARENT = 'SetPartialAuthenticationTokenForParent';
const TRIGGER_LOGOUT_IN_PARENT = 'TriggerLogoutInParent';
const EXPLORER_LISTENING_FOR_PARTIAL_TOKEN = 'ExplorerListeningForPartialToken';
const PARTIAL_AUTHENTICATION_TOKEN_RESPONSE = 'PartialAuthenticationTokenResponse';
const INTROSPECTION_QUERY_WITH_HEADERS = 'IntrospectionQueryWithHeaders';
const PARENT_LOGOUT_SUCCESS = 'ParentLogoutSuccess';

const defaultHandleRequest = ({
  legacyIncludeCookies
}) => {
  const handleRequestWithCookiePref = (endpointUrl, options) => fetch(endpointUrl, Object.assign(Object.assign({}, options), legacyIncludeCookies ? {
    credentials: 'include'
  } : // if the user doesn't pass this value then we should use the credentials option sent from the
  // studio postMessage request. otherwise this would overwrite it.
  legacyIncludeCookies !== undefined ? {
    credentials: 'omit'
  } : {}));

  return handleRequestWithCookiePref;
};

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function readMultipartWebStream(response, mimeType) {
  if (response.body === null) {
    throw new Error('Missing body');
  } else if (typeof response.body.tee !== 'function') {
    // not sure if we actually need this check in explorer?
    throw new Error('Streaming bodies not supported by provided fetch implementation');
  }

  const decoder = new TextDecoder('utf-8');
  let buffer = '';
  const messageBoundary = `--${mimeType.parameters.get('boundary') || '-'}`;
  const subscriptionTerminationMessageBoundary = '--graphql--';
  const reader = response.body.getReader();
  return {
    closeReadableStream: () => reader.cancel(),
    observable: new Observable(observer => {
      function readMultipartStream() {
        reader.read().then(iteration => {
          var _a, _b, _c;

          if (iteration.done) {
            (_a = observer.complete) === null || _a === void 0 ? void 0 : _a.call(observer);
            return;
          }

          const chunk = decoder.decode(iteration.value);
          buffer += chunk;
          let boundaryIndex = buffer.indexOf(messageBoundary);

          while (boundaryIndex > -1) {
            const message = buffer.slice(0, boundaryIndex);
            buffer = buffer.slice(boundaryIndex + messageBoundary.length);

            if (message.trim()) {
              const newLineSequence = '\r\n\r\n';
              let messageStartIndex; // if there are two instances of newLineSequence, this is a response with multiple parts
              // and the first part is a heartbeat: https://www.apollographql.com/docs/router/executing-operations/subscription-multipart-protocol/

              if (message.lastIndexOf(newLineSequence) !== message.indexOf(newLineSequence)) {
                const heartbeatStartIndex = message.indexOf(newLineSequence) + newLineSequence.length;
                messageStartIndex = message.substring(heartbeatStartIndex).indexOf(newLineSequence) + heartbeatStartIndex;
              } else {
                messageStartIndex = message.indexOf(newLineSequence);
              }

              const chunkHeaders = Object.fromEntries(message.slice(0, messageStartIndex).split('\n').map(line => {
                const i = line.indexOf(':');

                if (i > -1) {
                  const name = line.slice(0, i).trim();
                  const value = line.slice(i + 1).trim();
                  return [name, value];
                } else {
                  return null;
                }
              }).filter(h => !!h));

              if (((_b = chunkHeaders['content-type']) === null || _b === void 0 ? void 0 : _b.toLowerCase().indexOf('application/json')) === -1) {
                throw new Error('Unsupported patch content type');
              }

              const bodyText = message.slice(messageStartIndex);

              try {
                (_c = observer.next) === null || _c === void 0 ? void 0 : _c.call(observer, Object.assign({
                  data: JSON.parse(bodyText),
                  headers: chunkHeaders,
                  size: chunk.length
                }, chunk.indexOf(subscriptionTerminationMessageBoundary) > -1 ? {
                  shouldTerminate: true
                } : {}));
              } catch (err) {
                // const parseError = err as ServerParseError;
                // parseError.name = 'ServerParseError';
                // parseError.response = response;
                // parseError.statusCode = response.status;
                // parseError.bodyText = bodyText;
                throw err;
              }
            }

            boundaryIndex = buffer.indexOf(messageBoundary);
          }

          readMultipartStream();
        }).catch(err => {
          var _a, _b;

          if (err.name === 'AbortError') return; // if it is a network error, BUT there is graphql result info fire
          // the next observer before calling error this gives apollo-client
          // (and react-apollo) the `graphqlErrors` and `networkErrors` to
          // pass to UI this should only happen if we *also* have data as
          // part of the response key per the spec

          if (err.result && err.result.errors && err.result.data) {
            // if we don't call next, the UI can only show networkError
            // because AC didn't get any graphqlErrors this is graphql
            // execution result info (i.e errors and possibly data) this is
            // because there is no formal spec how errors should translate to
            // http status codes. So an auth error (401) could have both data
            // from a public field, errors from a private field, and a status
            // of 401
            // {
            //  user { // this will have errors
            //    firstName
            //  }
            //  products { // this is public so will have data
            //    cost
            //  }
            // }
            //
            // the result of above *could* look like this:
            // {
            //   data: { products: [{ cost: "$10" }] },
            //   errors: [{
            //      message: 'your session has timed out',
            //      path: []
            //   }]
            // }
            // status code of above would be a 401
            // in the UI you want to show data where you can, errors as data where you can
            // and use correct http status codes
            (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, {
              data: err.result,
              size: Infinity
            });
          }

          (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, err);
        });
      }

      readMultipartStream();
    })
  };
}

const serializeFetchParameter = (p, label) => {
  let serialized;

  try {
    serialized = JSON.stringify(p);
  } catch (e) {
    const parseError = new Error(`Network request failed. ${label} is not serializable`);
    throw parseError;
  }

  return serialized;
};
const constructMultipartForm = ({
  fileVariables: inputtedFileVariables,
  requestBody
}) => __awaiter(void 0, void 0, void 0, function* () {
  const fileVariables = inputtedFileVariables.map(fileVariable => Object.assign(Object.assign({}, fileVariable), {
    files: fileVariable.files.map(({
      arrayBuffer,
      fileName
    }) => new File([new Blob([arrayBuffer])], fileName))
  })); // the map element of a FormData maps indices to a single item array of variable names
  // as seen here https://github.com/jaydenseric/graphql-multipart-request-spec#file-list

  const map = {};
  let i = 0; // map must be the first thing in the form, followed by the files
  // other wise you get the error:
  // Misordered multipart fields; files should follow ‘map’ (https://github.com/jaydenseric/graphql-multipart-request-spec).

  const filesToAppend = []; // variables are added to the operation body with null values, the variable
  // name is used to match them to files uploaded in the later part of the request
  // according to the spec https://github.com/jaydenseric/graphql-multipart-request-spec

  let variablesWithNullsForFiles = requestBody.variables;
  fileVariables.forEach(({
    files,
    variableKey,
    isMultiFile
  }, fileVariableIndex) => {
    if (files === null || files === void 0 ? void 0 : files.length) {
      variablesWithNullsForFiles = Object.assign(Object.assign({}, variablesWithNullsForFiles), {
        [variableKey]: isMultiFile ? new Array(files.length).fill(null) : null
      });
      Array.from(files).forEach(file => {
        map[i] = [`${fileVariables.length > 1 ? `${fileVariableIndex}.` : ''}variables.${variableKey}${isMultiFile ? `.${i}` : ''}`]; // in the request, there is expected to be a number appended that corresponds to each file
        // https://github.com/jaydenseric/graphql-multipart-request-spec#file-list

        filesToAppend.push([i.toString(), file, file.name]);
        i++;
      });
    }
  });
  const form = new FormData();
  form.append('operations', serializeFetchParameter({
    query: requestBody.query,
    operationName: requestBody.operationName,
    variables: variablesWithNullsForFiles
  }, 'Payload'));
  form.append('map', JSON.stringify(map));
  filesToAppend.forEach(item => {
    form.append(item[0], item[1], item[2]);
  });
  return form;
});

// to each request's headers if not present

function getHeadersWithContentType(headers) {
  const headersWithContentType = headers !== null && headers !== void 0 ? headers : {};

  if (Object.keys(headersWithContentType).every(key => key.toLowerCase() !== 'content-type')) {
    headersWithContentType['content-type'] = 'application/json';
  }

  return headersWithContentType;
}

function sendPostMessageToEmbed({
  message,
  embeddedIFrameElement,
  embedUrl
}) {
  var _a;

  (_a = embeddedIFrameElement === null || embeddedIFrameElement === void 0 ? void 0 : embeddedIFrameElement.contentWindow) === null || _a === void 0 ? void 0 : _a.postMessage(message, embedUrl);
}
function executeOperation({
  endpointUrl,
  handleRequest,
  headers,
  includeCookies,
  operationId,
  operation,
  operationName,
  variables,
  fileVariables,
  embeddedIFrameElement,
  embedUrl,
  isMultipartSubscription,
  multipartSubscriptionClient
}) {
  return __awaiter(this, void 0, void 0, function* () {
    const requestBody = {
      query: operation,
      variables,
      operationName
    };
    let promise;

    if (fileVariables && fileVariables.length > 0) {
      const form = yield constructMultipartForm({
        fileVariables,
        requestBody
      });
      promise = handleRequest(endpointUrl, Object.assign({
        method: 'POST',
        headers: headers !== null && headers !== void 0 ? headers : {},
        body: form
      }, includeCookies ? {
        credentials: 'include'
      } : {}));
    } else {
      promise = handleRequest(endpointUrl, Object.assign({
        method: 'POST',
        headers: getHeadersWithContentType(headers),
        body: JSON.stringify(requestBody)
      }, !!includeCookies ? {
        credentials: 'include'
      } : {
        credentials: 'omit'
      }));
    }

    promise.then(response => __awaiter(this, void 0, void 0, function* () {
      var _a;

      const responseHeaders = {};
      response.headers.forEach((value, key) => {
        responseHeaders[key] = value;
      });
      const contentType = (_a = response.headers) === null || _a === void 0 ? void 0 : _a.get('content-type');
      const mimeType = contentType && new MIMEType(contentType);

      if (mimeType && mimeType.type === 'multipart' && mimeType.subtype === 'mixed') {
        multipartSubscriptionClient === null || multipartSubscriptionClient === void 0 ? void 0 : multipartSubscriptionClient.emit('connected');
        const {
          observable,
          closeReadableStream
        } = readMultipartWebStream(response, mimeType);
        let isFirst = true;
        const observableSubscription = observable.subscribe({
          next(data) {
            // if shouldTerminate is true, we got a server error
            // we handle this in Explorer, but we need to disconnect from
            // the readableStream & subscription here
            if ('payload' in data.data) {
              if ('shouldTerminate' in data && data.shouldTerminate) {
                observableSubscription.unsubscribe();
                closeReadableStream(); // the status being disconnected will be handled in the Explorer
                // but we send a pm just in case

                sendPostMessageToEmbed({
                  message: {
                    name: EXPLORER_SET_SOCKET_STATUS,
                    status: 'disconnected'
                  },
                  embeddedIFrameElement,
                  embedUrl
                });
              }

              sendPostMessageToEmbed({
                message: {
                  name: EXPLORER_SUBSCRIPTION_RESPONSE,
                  // Include the same operation ID in the response message's name
                  // so the Explorer knows which operation it's associated with
                  operationId,
                  response: {
                    data: data.data,
                    status: response.status,
                    headers: isFirst ? [responseHeaders, ...(Array.isArray(data.headers) ? data.headers : data.headers ? [data.headers] : [])] : data.headers,
                    size: data.size
                  }
                },
                embeddedIFrameElement,
                embedUrl
              });
            } else {
              sendPostMessageToEmbed({
                message: {
                  name: EXPLORER_QUERY_MUTATION_RESPONSE,
                  // Include the same operation ID in the response message's name
                  // so the Explorer knows which operation it's associated with
                  operationId,
                  response: {
                    incremental: data.data.incremental,
                    data: data.data.data,
                    errors: data.data.errors,
                    extensions: data.data.extensions,
                    path: data.data.path,
                    status: response.status,
                    headers: isFirst ? [responseHeaders, ...(Array.isArray(data.headers) ? data.headers : data.headers ? [data.headers] : [])] : data.headers,
                    hasNext: true,
                    size: data.size
                  }
                },
                embeddedIFrameElement,
                embedUrl
              });
            }

            isFirst = false;
          },

          error(err) {
            const error = err && typeof err === 'object' && 'message' in err && typeof err.message === 'string' ? Object.assign({
              message: err.message
            }, 'stack' in err && typeof err.stack === 'string' ? {
              stack: err.stack
            } : {}) : undefined;
            sendPostMessageToEmbed({
              message: {
                name: isMultipartSubscription ? EXPLORER_SUBSCRIPTION_RESPONSE : EXPLORER_QUERY_MUTATION_RESPONSE,
                // Include the same operation ID in the response message's name
                // so the Explorer knows which operation it's associated with
                operationId,
                response: Object.assign({
                  data: null,
                  error
                }, !isMultipartSubscription ? {
                  hasNext: false
                } : {})
              },
              embeddedIFrameElement,
              embedUrl
            });
          },

          complete() {
            sendPostMessageToEmbed({
              message: {
                name: isMultipartSubscription ? EXPLORER_SUBSCRIPTION_RESPONSE : EXPLORER_QUERY_MUTATION_RESPONSE,
                // Include the same operation ID in the response message's name
                // so the Explorer knows which operation it's associated with
                operationId,
                response: Object.assign({
                  data: null,
                  status: response.status,
                  headers: isFirst ? responseHeaders : undefined
                }, !isMultipartSubscription ? {
                  hasNext: false
                } : {})
              },
              embeddedIFrameElement,
              embedUrl
            });
          }

        });

        if (multipartSubscriptionClient) {
          multipartSubscriptionClient.stopListeningCallback = () => {
            closeReadableStream();
            observableSubscription.unsubscribe();
          };
        }
      } else {
        const json = yield response.json(); // if we didn't get the mime type multi part response,
        // something went wrong with this multipart subscription

        multipartSubscriptionClient === null || multipartSubscriptionClient === void 0 ? void 0 : multipartSubscriptionClient.emit('error');
        multipartSubscriptionClient === null || multipartSubscriptionClient === void 0 ? void 0 : multipartSubscriptionClient.emit('disconnected');
        sendPostMessageToEmbed({
          message: {
            name: isMultipartSubscription ? EXPLORER_SUBSCRIPTION_RESPONSE : EXPLORER_QUERY_MUTATION_RESPONSE,
            // Include the same operation ID in the response message's name
            // so the Explorer knows which operation it's associated with
            operationId,
            response: Object.assign(Object.assign({}, json), {
              status: response.status,
              headers: responseHeaders,
              hasNext: false
            })
          },
          embeddedIFrameElement,
          embedUrl
        });
      }
    })).catch(err => {
      multipartSubscriptionClient === null || multipartSubscriptionClient === void 0 ? void 0 : multipartSubscriptionClient.emit('error', err);
      multipartSubscriptionClient === null || multipartSubscriptionClient === void 0 ? void 0 : multipartSubscriptionClient.emit('disconnected');
      const error = err && typeof err === 'object' && 'message' in err && typeof err.message === 'string' ? Object.assign({
        message: err.message
      }, 'stack' in err && typeof err.stack === 'string' ? {
        stack: err.stack
      } : {}) : undefined;
      sendPostMessageToEmbed({
        message: {
          name: isMultipartSubscription ? EXPLORER_SUBSCRIPTION_RESPONSE : EXPLORER_QUERY_MUTATION_RESPONSE,
          // Include the same operation ID in the response message's name
          // so the Explorer knows which operation it's associated with
          operationId,
          response: Object.assign({
            data: null,
            error
          }, !isMultipartSubscription ? {
            hasNext: false
          } : {})
        },
        embeddedIFrameElement,
        embedUrl
      });
    });
  });
}
function executeIntrospectionRequest({
  endpointUrl,
  headers,
  includeCookies,
  introspectionRequestBody,
  embeddedIFrameElement,
  embedUrl,
  handleRequest,
  operationId
}) {
  return __awaiter(this, void 0, void 0, function* () {
    const {
      query,
      operationName
    } = JSON.parse(introspectionRequestBody);
    return handleRequest(endpointUrl, Object.assign({
      method: 'POST',
      headers: getHeadersWithContentType(headers),
      body: JSON.stringify({
        query,
        operationName
      })
    }, !!includeCookies ? {
      credentials: 'include'
    } : {
      credentials: 'omit'
    })).then(response => response.json()).then(response => {
      if (response.errors && response.errors.length) {
        sendPostMessageToEmbed({
          message: {
            name: SCHEMA_ERROR,
            errors: response.errors,
            operationId
          },
          embeddedIFrameElement,
          embedUrl
        });
      }

      sendPostMessageToEmbed({
        message: {
          name: SCHEMA_RESPONSE,
          schema: response.data,
          operationId
        },
        embeddedIFrameElement,
        embedUrl
      });
    }).catch(error => {
      sendPostMessageToEmbed({
        message: {
          name: SCHEMA_ERROR,
          error: error,
          operationId
        },
        embeddedIFrameElement,
        embedUrl
      });
    });
  });
}
const handleAuthenticationPostMessage = ({
  event,
  embeddedIFrameElement,
  embedUrl
}) => {
  const {
    data
  } = event; // When the embed authenticates, save the partial token in local storage

  if (data.name === SET_PARTIAL_AUTHENTICATION_TOKEN_FOR_PARENT) {
    const partialEmbedApiKeysString = window.localStorage.getItem('apolloStudioEmbeddedExplorerEncodedApiKey');
    const partialEmbedApiKeys = partialEmbedApiKeysString ? JSON.parse(partialEmbedApiKeysString) : {};
    partialEmbedApiKeys[data.localStorageKey] = data.partialToken;
    window.localStorage.setItem('apolloStudioEmbeddedExplorerEncodedApiKey', JSON.stringify(partialEmbedApiKeys));
  } // When the embed logs out, remove the partial token in local storage


  if (data.name === TRIGGER_LOGOUT_IN_PARENT) {
    const partialEmbedApiKeysString = window.localStorage.getItem('apolloStudioEmbeddedExplorerEncodedApiKey');
    const partialEmbedApiKeys = partialEmbedApiKeysString ? JSON.parse(partialEmbedApiKeysString) : {};
    delete partialEmbedApiKeys[data.localStorageKey];
    window.localStorage.setItem('apolloStudioEmbeddedExplorerEncodedApiKey', JSON.stringify(partialEmbedApiKeys));
    sendPostMessageToEmbed({
      message: {
        name: PARENT_LOGOUT_SUCCESS
      },
      embeddedIFrameElement,
      embedUrl
    });
  }

  if (data.name === EXPLORER_LISTENING_FOR_PARTIAL_TOKEN && data.localStorageKey) {
    const partialEmbedApiKeysString = window.localStorage.getItem('apolloStudioEmbeddedExplorerEncodedApiKey');
    const partialEmbedApiKeys = partialEmbedApiKeysString ? JSON.parse(partialEmbedApiKeysString) : {};

    if (partialEmbedApiKeys && partialEmbedApiKeys[data.localStorageKey]) {
      sendPostMessageToEmbed({
        message: {
          name: PARTIAL_AUTHENTICATION_TOKEN_RESPONSE,
          partialToken: partialEmbedApiKeys[data.localStorageKey]
        },
        embeddedIFrameElement,
        embedUrl
      });
    }
  }
};

function assertUnreachable(x) {
  throw new Error(`Didn't expect to get here ${x}`);
}

class SubscriptionClient {
  constructor(url, headers, protocol) {
    this.unsubscribeFunctions = [];
    this.protocol = protocol;
    this.url = url;
    this.headers = headers;
  }

  get graphWsClient() {
    var _a, _b;

    const client = (_a = this._graphWsClient) !== null && _a !== void 0 ? _a : createClient({
      url: this.url,
      lazy: true,
      connectionParams: (_b = this.headers) !== null && _b !== void 0 ? _b : {},
      keepAlive: 10000
    });
    this._graphWsClient = client;
    return client;
  }

  get transportSubscriptionClient() {
    var _a, _b;

    const client = (_a = this._transportSubscriptionClient) !== null && _a !== void 0 ? _a : new SubscriptionClient$1(this.url, {
      reconnect: true,
      lazy: true,
      connectionParams: (_b = this.headers) !== null && _b !== void 0 ? _b : {}
    });
    this._transportSubscriptionClient = client;
    return client;
  }

  get multipartClient() {
    var _a;

    const client = (_a = this._multipartClient) !== null && _a !== void 0 ? _a : Object.assign(new EventEmitter(), {
      stopListeningCallback: undefined
    });
    this._multipartClient = client;
    return client;
  }

  onConnected(callback) {
    if (this.protocol === 'http-multipart') {
      this.multipartClient.on('connected', callback);
      return () => this.multipartClient.off('connected', callback);
    }

    if (this.protocol === 'graphql-ws') {
      return this.graphWsClient.on('connected', callback);
    }

    if (this.protocol === 'subscriptions-transport-ws') {
      return this.transportSubscriptionClient.onConnected(callback);
    }

    assertUnreachable(this.protocol);
  }

  onConnecting(callback) {
    if (this.protocol === 'http-multipart') {
      return;
    }

    if (this.protocol === 'graphql-ws') {
      return this.graphWsClient.on('connecting', callback);
    }

    if (this.protocol === 'subscriptions-transport-ws') {
      return this.transportSubscriptionClient.onConnecting(callback);
    }

    assertUnreachable(this.protocol);
  }

  onError(callback) {
    if (this.protocol === 'http-multipart') {
      this.multipartClient.on('error', callback);
      return () => this.multipartClient.off('error', callback);
    }

    if (this.protocol === 'graphql-ws') {
      return this.graphWsClient.on('error', error => callback(error));
    }

    if (this.protocol === 'subscriptions-transport-ws') {
      return this.transportSubscriptionClient.onError(e => callback(e));
    }

    assertUnreachable(this.protocol);
  }

  onReconnecting(callback) {
    if (this.protocol === 'http-multipart') {
      return;
    }

    if (this.protocol === 'graphql-ws') {
      return;
    }

    if (this.protocol === 'subscriptions-transport-ws') {
      return this.transportSubscriptionClient.onReconnecting(callback);
    }

    assertUnreachable(this.protocol);
  }

  onReconnected(callback) {
    if (this.protocol === 'http-multipart') {
      return;
    }

    if (this.protocol === 'graphql-ws') {
      return;
    }

    if (this.protocol === 'subscriptions-transport-ws') {
      return this.transportSubscriptionClient.onReconnected(callback);
    }

    assertUnreachable(this.protocol);
  }

  onDisconnected(callback) {
    if (this.protocol === 'http-multipart') {
      this.multipartClient.on('disconnected', callback);
      return () => this.multipartClient.off('disconnected', callback);
    }

    if (this.protocol === 'graphql-ws') {
      return this.graphWsClient.on('closed', callback);
    }

    if (this.protocol === 'subscriptions-transport-ws') {
      return this.transportSubscriptionClient.onDisconnected(callback);
    }

    assertUnreachable(this.protocol);
  }

  dispose() {
    var _a, _b;

    if (this.protocol === 'http-multipart') {
      (_b = (_a = this.multipartClient).stopListeningCallback) === null || _b === void 0 ? void 0 : _b.call(_a);
      return;
    }

    if (this.protocol === 'graphql-ws') {
      return this.graphWsClient.dispose();
    }

    if (this.protocol === 'subscriptions-transport-ws') {
      return this.transportSubscriptionClient.close();
    }

    assertUnreachable(this.protocol);
  }

  request(params) {
    return {
      subscribe: subscribeParams => __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c, _d;

        if (this.protocol === 'http-multipart' && params.httpMultipartParams) {
          // we only use subscribeParams for websockets, for http multipart subs
          // we do all responding in executeOperation, since this is where we set
          // up the Observable
          yield executeOperation({
            operation: params.query,
            operationName: params.operationName,
            variables: params.variables,
            headers: (_a = this.headers) !== null && _a !== void 0 ? _a : {},
            includeCookies: (_c = (_b = params.httpMultipartParams) === null || _b === void 0 ? void 0 : _b.includeCookies) !== null && _c !== void 0 ? _c : false,
            endpointUrl: this.url,
            embeddedIFrameElement: params.embeddedIFrameElement,
            embedUrl: params.embedUrl,
            operationId: params.operationId,
            handleRequest: (_d = params.httpMultipartParams) === null || _d === void 0 ? void 0 : _d.handleRequest,
            isMultipartSubscription: true,
            multipartSubscriptionClient: this.multipartClient
          });
        }

        if (this.protocol === 'graphql-ws') {
          this.unsubscribeFunctions.push(this.graphWsClient.subscribe(params, Object.assign(Object.assign({}, subscribeParams), {
            next: data => {
              var _a;

              return (_a = subscribeParams.next) === null || _a === void 0 ? void 0 : _a.call(subscribeParams, data);
            },
            error: error => {
              var _a;

              return (_a = subscribeParams.error) === null || _a === void 0 ? void 0 : _a.call(subscribeParams, error);
            },
            complete: () => {}
          })));
        }

        if (this.protocol === 'subscriptions-transport-ws') {
          return this.transportSubscriptionClient.request(params).subscribe(subscribeParams);
        } else {
          return undefined;
        }
      })
    };
  }

  unsubscribeAll() {
    var _a, _b;

    if (this.protocol === 'http-multipart') {
      (_b = (_a = this.multipartClient).stopListeningCallback) === null || _b === void 0 ? void 0 : _b.call(_a);
    }

    if (this.protocol === 'graphql-ws') {
      this.unsubscribeFunctions.forEach(off => {
        off();
      });
      this.unsubscribeFunctions = [];
    }

    if (this.protocol === 'subscriptions-transport-ws') {
      return this.transportSubscriptionClient.unsubscribeAll();
    }
  }

}

function setParentSocketError({
  error,
  embeddedIFrameElement,
  embedUrl
}) {
  sendPostMessageToEmbed({
    message: {
      name: EXPLORER_SET_SOCKET_ERROR,
      error
    },
    embeddedIFrameElement,
    embedUrl
  });
}

function setParentSocketStatus({
  status,
  embeddedIFrameElement,
  embedUrl
}) {
  sendPostMessageToEmbed({
    message: {
      name: EXPLORER_SET_SOCKET_STATUS,
      status
    },
    embeddedIFrameElement,
    embedUrl
  });
}

function executeSubscription({
  operation,
  operationName,
  variables,
  headers,
  embeddedIFrameElement,
  operationId,
  embedUrl,
  subscriptionUrl,
  protocol,
  httpMultipartParams
}) {
  const client = new SubscriptionClient(subscriptionUrl, headers !== null && headers !== void 0 ? headers : {}, protocol);

  const checkForSubscriptionTermination = event => {
    if (event.data.name === EXPLORER_SUBSCRIPTION_TERMINATION) {
      client.unsubscribeAll();
      window.removeEventListener('message', checkForSubscriptionTermination);
    }
  };

  window.addEventListener('message', checkForSubscriptionTermination);
  client.onError(e => setParentSocketError({
    error: JSON.parse(JSON.stringify(e)),
    embeddedIFrameElement,
    embedUrl
  }));
  client.onConnected(() => {
    setParentSocketError({
      error: undefined,
      embeddedIFrameElement,
      embedUrl
    });
    setParentSocketStatus({
      status: 'connected',
      embeddedIFrameElement,
      embedUrl
    });
  });
  client.onReconnected(() => {
    setParentSocketError({
      error: undefined,
      embeddedIFrameElement,
      embedUrl
    });
    setParentSocketStatus({
      status: 'connected',
      embeddedIFrameElement,
      embedUrl
    });
  });
  client.onConnecting(() => setParentSocketStatus({
    status: 'connecting',
    embeddedIFrameElement,
    embedUrl
  }));
  client.onReconnecting(() => setParentSocketStatus({
    status: 'connecting',
    embeddedIFrameElement,
    embedUrl
  }));
  client.onDisconnected(() => setParentSocketStatus({
    status: 'disconnected',
    embeddedIFrameElement,
    embedUrl
  }));
  client.request({
    query: operation,
    variables: variables !== null && variables !== void 0 ? variables : {},
    operationName,
    embeddedIFrameElement,
    embedUrl,
    httpMultipartParams,
    operationId
  }).subscribe( // we only use these callbacks for websockets, for http multipart subs
  // we do all responding in executeOperation, since this is where we set
  // up the Observable
  {
    next(data) {
      sendPostMessageToEmbed({
        message: {
          name: EXPLORER_SUBSCRIPTION_RESPONSE,
          // Include the same operation ID in the response message's name
          // so the Explorer knows which operation it's associated with
          operationId,
          // we use different versions of graphql in Explorer & here,
          // Explorer expects an Object, which is what this is in reality
          response: {
            data: data
          }
        },
        embeddedIFrameElement,
        embedUrl
      });
    },

    error: error => {
      sendPostMessageToEmbed({
        message: {
          name: EXPLORER_SUBSCRIPTION_RESPONSE,
          // Include the same operation ID in the response message's name
          // so the Explorer knows which operation it's associated with
          operationId,
          response: {
            error: JSON.parse(JSON.stringify(error))
          }
        },
        embeddedIFrameElement,
        embedUrl
      });
    }
  });
  return {
    dispose: () => window.removeEventListener('message', checkForSubscriptionTermination)
  };
}

function setupSandboxEmbedRelay({
  handleRequest,
  embeddedSandboxIFrameElement,
  __testLocal__
}) {
  const embedUrl = EMBEDDABLE_SANDBOX_URL(__testLocal__); // Callback definition

  const onPostMessageReceived = event => {
    handleAuthenticationPostMessage({
      event,
      embedUrl,
      embeddedIFrameElement: embeddedSandboxIFrameElement
    }); // Any pm can be listened for here, not just the ones we know the
    // structure of. Some have a data field that is not an object

    const data = typeof event.data === 'object' ? event.data : undefined;

    if (data && 'name' in data) {
      // When embed connects, send a handshake message
      if (data.name === EXPLORER_LISTENING_FOR_HANDSHAKE) {
        sendPostMessageToEmbed({
          message: {
            name: HANDSHAKE_RESPONSE,
            parentHref: window.location.href
          },
          embeddedIFrameElement: embeddedSandboxIFrameElement,
          embedUrl
        });
      }

      if (data.name === INTROSPECTION_QUERY_WITH_HEADERS) {
        const {
          introspectionRequestBody,
          introspectionRequestHeaders,
          includeCookies,
          sandboxEndpointUrl,
          operationId
        } = data;

        if (sandboxEndpointUrl) {
          executeIntrospectionRequest({
            endpointUrl: sandboxEndpointUrl,
            introspectionRequestBody,
            headers: introspectionRequestHeaders,
            includeCookies,
            embeddedIFrameElement: embeddedSandboxIFrameElement,
            embedUrl,
            handleRequest,
            operationId
          });
        }
      } // Check to see if the posted message indicates that the user is
      // executing a query or mutation or subscription in the Explorer


      const isQueryOrMutation = data.name === EXPLORER_QUERY_MUTATION_REQUEST;
      const isSubscription = data.name === EXPLORER_SUBSCRIPTION_REQUEST; // If the user is executing a query or mutation or subscription...

      if ((isQueryOrMutation || isSubscription) && data.operation && data.operationId) {
        // Extract the operation details from the event.data object
        const {
          operation,
          variables,
          operationName,
          operationId,
          headers
        } = data;

        if (isQueryOrMutation) {
          const {
            endpointUrl,
            includeCookies
          } = data;

          if (!endpointUrl) {
            throw new Error('Something went wrong, we should not have gotten here. The sandbox endpoint url was not sent.');
          }

          executeOperation({
            endpointUrl,
            handleRequest,
            headers,
            includeCookies,
            embeddedIFrameElement: embeddedSandboxIFrameElement,
            operationId,
            operation,
            variables,
            fileVariables: 'fileVariables' in data ? data.fileVariables : undefined,
            operationName,
            embedUrl,
            isMultipartSubscription: false
          });
        } else if (isSubscription) {
          const {
            httpMultipartParams
          } = data;
          executeSubscription({
            operation,
            operationName,
            variables,
            headers,
            embeddedIFrameElement: embeddedSandboxIFrameElement,
            operationId,
            embedUrl,
            subscriptionUrl: data.subscriptionUrl,
            protocol: data.protocol,
            httpMultipartParams: Object.assign(Object.assign({}, httpMultipartParams), {
              handleRequest
            })
          });
        }
      }
    }
  }; // Execute our callback whenever window.postMessage is called


  window.addEventListener('message', onPostMessageReceived);
  return {
    dispose: () => window.removeEventListener('message', onPostMessageReceived)
  };
}

var name = "@apollo/sandbox";
var version = "2.5.1";
var author = "packages@apollographql.com";
var license = "MIT";
var repository = {
	type: "git",
	url: "https://github.com/apollographql/embeddable-explorer/sandbox"
};
var homepage = "https://github.com/apollographql/embeddable-explorer/sandbox#readme";
var main = "dist/index.cjs";
var module = "dist/index.mjs";
var typings = "dist/src/index.d.ts";
var engines = {
	node: ">=12.0",
	npm: ">=7.0"
};
var volta = {
	node: "16.13.0",
	npm: "8.3.1"
};
var scripts = {
	build: "npm run build:cjs-esm",
	"build:cjs-esm": "rm -rf dist && rollup -c buildHelpers/rollup.cjs-esm.config.js && cp src/index.cjs dist/index.cjs && cp src/react/index.cjs dist/react/index.cjs && node ./buildHelpers/prepareDist.js sandbox",
	"build:umd": "rm -rf dist && rollup -c buildHelpers/rollup.umd.config.js",
	lint: "eslint --ext .js,.jsx,.ts,.tsx .",
	size: "size-limit",
	analyze: "size-limit --why",
	"typescript:check": "tsc --noEmit",
	"prettier:check": "prettier --check .",
	"prettier:fix": "prettier --write ."
};
var husky = {
	hooks: {
		"pre-commit": "npm run lint"
	}
};
var prettier = {
	printWidth: 80,
	semi: true,
	singleQuote: true,
	trailingComma: "es5",
	endOfLine: "auto"
};
var peerDependencies = {
	react: "^16.8.0 || ^17.0.0 || ^18.0.0",
	"react-dom": "^16.8.0 || ^17.0.0 || ^18.0.0"
};
var peerDependenciesMeta = {
	react: {
		optional: true
	},
	"react-dom": {
		optional: true
	}
};
var dependencies = {
	"@types/whatwg-mimetype": "^3.0.0",
	eventemitter3: "3.1.0",
	"graphql-ws": "^5.9.0",
	"subscriptions-transport-ws": "^0.11.0",
	"whatwg-mimetype": "^3.0.0",
	"zen-observable-ts": "^1.1.0"
};
var packageJSON = {
	name: name,
	version: version,
	author: author,
	license: license,
	repository: repository,
	homepage: homepage,
	main: main,
	module: module,
	typings: typings,
	engines: engines,
	volta: volta,
	scripts: scripts,
	husky: husky,
	prettier: prettier,
	"size-limit": [
	{
		path: "dist/index.production.min.js",
		limit: "10 KB"
	},
	{
		path: "dist/index.mjs",
		limit: "10 KB"
	}
],
	peerDependencies: peerDependencies,
	peerDependenciesMeta: peerDependenciesMeta,
	dependencies: dependencies
};

let idCounter = 0;
class EmbeddedSandbox {
  constructor(options) {
    var _a;

    this.options = options;
    this.__testLocal__ = !!this.options.__testLocal__;
    this.validateOptions();
    this.handleRequest = (_a = this.options.handleRequest) !== null && _a !== void 0 ? _a : defaultHandleRequest({
      legacyIncludeCookies: this.options.includeCookies
    });
    this.uniqueEmbedInstanceId = idCounter++;
    this.embeddedSandboxIFrameElement = this.injectEmbed();
    this.disposable = setupSandboxEmbedRelay({
      embeddedSandboxIFrameElement: this.embeddedSandboxIFrameElement,
      handleRequest: this.handleRequest,
      __testLocal__: !!this.__testLocal__
    });
  }

  dispose() {
    var _a; // remove the dom element


    (_a = document.getElementById(IFRAME_DOM_ID(this.uniqueEmbedInstanceId))) === null || _a === void 0 ? void 0 : _a.remove(); // remove the listener

    this.disposable.dispose();
  }

  injectEmbed() {
    var _a, _b, _c, _d, _e;

    let element;
    const {
      target,
      runTelemetry
    } = this.options;
    const {
      includeCookies,
      sharedHeaders
    } = this.options.initialState || {};
    const queryParams = Object.assign(Object.assign(Object.assign({
      runtime: this.options.runtime,
      endpoint: this.options.initialEndpoint,
      subscriptionEndpoint: this.options.initialSubscriptionEndpoint
    }, this.options.initialState && 'collectionId' in this.options.initialState ? {
      defaultCollectionEntryId: this.options.initialState.operationId,
      defaultCollectionId: this.options.initialState.collectionId
    } : {}), this.options.initialState && 'document' in this.options.initialState ? {
      defaultDocument: this.options.initialState.document ? encodeURIComponent(this.options.initialState.document) : undefined,
      defaultVariables: this.options.initialState.variables ? encodeURIComponent(JSON.stringify(this.options.initialState.variables, null, 2)) : undefined,
      defaultHeaders: this.options.initialState.headers ? encodeURIComponent(JSON.stringify(this.options.initialState.headers)) : undefined
    } : {}), {
      sharedHeaders: sharedHeaders ? encodeURIComponent(JSON.stringify(sharedHeaders)) : undefined,
      defaultIncludeCookies: includeCookies,
      hideCookieToggle: (_a = this.options.hideCookieToggle) !== null && _a !== void 0 ? _a : true,
      parentSupportsSubscriptions: true,
      version: packageJSON.version,
      runTelemetry: runTelemetry === undefined ? true : runTelemetry,
      initialRequestQueryPlan: (_b = this.options.initialRequestQueryPlan) !== null && _b !== void 0 ? _b : false,
      shouldDefaultAutoupdateSchema: (_d = (_c = this.options.initialState) === null || _c === void 0 ? void 0 : _c.pollForSchemaUpdates) !== null && _d !== void 0 ? _d : true,
      endpointIsEditable: this.options.endpointIsEditable
    });
    const queryString = Object.entries(queryParams).filter(([_, value]) => value !== undefined).map(([key, value]) => `${key}=${value}`).join('&');

    if (typeof target === 'string') {
      element = (_e = document === null || document === void 0 ? void 0 : document.querySelector) === null || _e === void 0 ? void 0 : _e.call(document, target);
    } else {
      element = target;
    }

    const iframeElement = document.createElement('iframe');
    iframeElement.src = `${EMBEDDABLE_SANDBOX_URL(this.__testLocal__)}?${queryString}`;
    iframeElement.id = IFRAME_DOM_ID(this.uniqueEmbedInstanceId); // default to `true` (`true` and `undefined` both ok)

    if (this.options.allowDynamicStyles !== false) {
      iframeElement.setAttribute('style', 'height: 100%; width: 100%; border: none;');
    }

    element === null || element === void 0 ? void 0 : element.appendChild(iframeElement); // inject the Apollo favicon if there is not one on this page

    fetch(`${window.location.origin}/favicon.ico`).then(response => {
      if (response.status === 404) {
        var existingLink = document.querySelector('link[rel*="icon"]');

        if (!existingLink) {
          var darkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
          ['icon', 'apple-touch-icon'].forEach(id => {
            var link = document.createElement('link');
            link.rel = id;
            link.href = `https://embeddable-explorer.cdn.apollographql.com/_latest/public/assets/favicon${darkMode ? '-dark' : ''}.png`;
            document.head.appendChild(link);
          });
        }
      }
    }).catch(() => {// do nothing with the error
    });
    return iframeElement;
  }

  validateOptions() {
    var _a;

    if (!this.options.target) {
      throw new Error('"target" is required');
    }

    if (this.options.includeCookies !== undefined) {
      console.warn('Passing `includeCookies` is deprecated. If you would like to set a default includeCookies value, please use `initialState.includeCookies` instead.');
    }

    if (this.options.includeCookies !== undefined && (this.options.hideCookieToggle !== undefined || ((_a = this.options.initialState) === null || _a === void 0 ? void 0 : _a.includeCookies) !== undefined)) {
      throw new Error('Passing `includeCookies` is deprecated and will override your sandbox connection settings configuration.');
    }
  }

}

export { EmbeddedSandbox as E };
