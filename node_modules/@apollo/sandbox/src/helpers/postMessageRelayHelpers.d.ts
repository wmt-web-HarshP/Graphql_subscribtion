import type { ExecutionResult, GraphQLError, IntrospectionQuery } from 'graphql';
import { PARTIAL_AUTHENTICATION_TOKEN_RESPONSE, EXPLORER_QUERY_MUTATION_RESPONSE, HANDSHAKE_RESPONSE, SCHEMA_ERROR, SCHEMA_RESPONSE, SET_PARTIAL_AUTHENTICATION_TOKEN_FOR_PARENT, EXPLORER_LISTENING_FOR_PARTIAL_TOKEN, PARENT_LOGOUT_SUCCESS, TRIGGER_LOGOUT_IN_PARENT, EXPLORER_SUBSCRIPTION_RESPONSE, EXPLORER_SET_SOCKET_ERROR, EXPLORER_SET_SOCKET_STATUS, TRACE_KEY, EXPLORER_LISTENING_FOR_HANDSHAKE, EXPLORER_QUERY_MUTATION_REQUEST, EXPLORER_SUBSCRIPTION_REQUEST, EXPLORER_SUBSCRIPTION_TERMINATION, EXPLORER_LISTENING_FOR_SCHEMA, INTROSPECTION_QUERY_WITH_HEADERS } from './constants';
import type { JSONObject, JSONValue } from './types';
import type { ObjMap } from 'graphql/jsutils/ObjMap';
import type { GraphQLSubscriptionLibrary, HTTPMultipartClient } from './subscriptionPostMessageRelayHelpers';
import { FileVariable } from './constructMultipartForm';
export type HandleRequest = (endpointUrl: string, options: Omit<RequestInit, 'headers'> & {
    headers: Record<string, string>;
}) => Promise<Response>;
export type SocketStatus = 'disconnected' | 'connecting' | 'connected';
export declare function sendPostMessageToEmbed({ message, embeddedIFrameElement, embedUrl, }: {
    message: OutgoingEmbedMessage;
    embeddedIFrameElement: HTMLIFrameElement;
    embedUrl: string;
}): void;
export type ResponseError = {
    message: string;
    stack?: string;
};
export interface ResponseData {
    data?: Record<string, unknown> | JSONValue | ObjMap<unknown>;
    path?: Array<string | number>;
    errors?: readonly GraphQLError[];
    extensions?: {
        [TRACE_KEY]?: string;
    };
}
type ExplorerResponse = ResponseData & {
    incremental?: Array<ResponseData & {
        path: NonNullable<ResponseData['path']>;
    }>;
    error?: ResponseError;
    status?: number;
    headers?: Record<string, string> | Record<string, string>[];
    hasNext?: boolean;
    size?: number;
};
export interface MultipartSubscriptionResponse {
    data: {
        errors?: Array<GraphQLError>;
        payload: (ResponseData & {
            error?: {
                message: string;
                stack?: string;
            };
        }) | null;
    };
    headers?: Record<string, string> | Record<string, string>[];
    size: number;
    status?: number;
}
export type ExplorerSubscriptionResponse = {
    data?: ExecutionResult<JSONObject>;
    error?: Error;
    errors?: GraphQLError[];
} | MultipartSubscriptionResponse | {
    data: null;
    error?: ResponseError;
    status?: number;
    headers?: Record<string, string> | Record<string, string>[];
};
export type OutgoingEmbedMessage = {
    name: typeof SCHEMA_ERROR;
    error?: string;
    errors?: Array<GraphQLError>;
    operationId: string;
} | {
    name: typeof SCHEMA_RESPONSE;
    schema: IntrospectionQuery | string | undefined;
    operationId: string;
} | {
    name: typeof HANDSHAKE_RESPONSE;
    graphRef?: string;
    inviteToken?: string;
    accountId?: string;
    parentHref?: string;
} | {
    name: typeof PARTIAL_AUTHENTICATION_TOKEN_RESPONSE;
    partialToken?: string;
} | {
    name: typeof EXPLORER_QUERY_MUTATION_RESPONSE;
    operationId: string;
    response: ExplorerResponse;
} | {
    name: typeof EXPLORER_SUBSCRIPTION_RESPONSE;
    operationId: string;
    response: ExplorerSubscriptionResponse;
} | {
    name: typeof EXPLORER_SET_SOCKET_ERROR;
    error: Error | undefined;
} | {
    name: typeof EXPLORER_SET_SOCKET_STATUS;
    status: SocketStatus;
} | {
    name: typeof PARENT_LOGOUT_SUCCESS;
};
export type IncomingEmbedMessage = MessageEvent<{
    name: typeof EXPLORER_LISTENING_FOR_HANDSHAKE;
}> | MessageEvent<{
    name: typeof EXPLORER_QUERY_MUTATION_REQUEST;
    operationId: string;
    operationName?: string;
    operation: string;
    variables?: Record<string, string>;
    headers?: Record<string, string>;
    includeCookies?: boolean;
    endpointUrl: string;
    fileVariables?: FileVariable[];
}> | MessageEvent<{
    name: typeof EXPLORER_SUBSCRIPTION_REQUEST;
    operationId: string;
    operation: string;
    variables?: Record<string, string>;
    operationName?: string;
    headers?: Record<string, string>;
    subscriptionUrl: string;
    protocol: GraphQLSubscriptionLibrary;
    httpMultipartParams: {
        includeCookies: boolean | undefined;
    };
}> | MessageEvent<{
    name: typeof EXPLORER_SUBSCRIPTION_TERMINATION;
    operationId: string;
}> | MessageEvent<{
    name: typeof EXPLORER_LISTENING_FOR_SCHEMA;
}> | MessageEvent<{
    name: typeof SET_PARTIAL_AUTHENTICATION_TOKEN_FOR_PARENT;
    localStorageKey: string;
    partialToken: string;
}> | MessageEvent<{
    name: typeof TRIGGER_LOGOUT_IN_PARENT;
    localStorageKey: string;
}> | MessageEvent<{
    name: typeof EXPLORER_LISTENING_FOR_PARTIAL_TOKEN;
    localStorageKey?: string;
}> | MessageEvent<{
    name: typeof INTROSPECTION_QUERY_WITH_HEADERS;
    introspectionRequestBody: string;
    introspectionRequestHeaders: Record<string, string>;
    includeCookies?: boolean;
    sandboxEndpointUrl?: string;
    operationId: string;
}>;
export declare function executeOperation({ endpointUrl, handleRequest, headers, includeCookies, operationId, operation, operationName, variables, fileVariables, embeddedIFrameElement, embedUrl, isMultipartSubscription, multipartSubscriptionClient, }: {
    endpointUrl: string;
    handleRequest: HandleRequest;
    headers?: Record<string, string>;
    includeCookies?: boolean;
    operationId: string;
    operation: string;
    operationName: string | undefined;
    variables?: Record<string, string>;
    fileVariables?: FileVariable[] | undefined;
    embeddedIFrameElement: HTMLIFrameElement;
    embedUrl: string;
    isMultipartSubscription: boolean;
    multipartSubscriptionClient?: HTTPMultipartClient;
}): Promise<void>;
export declare function executeIntrospectionRequest({ endpointUrl, headers, includeCookies, introspectionRequestBody, embeddedIFrameElement, embedUrl, handleRequest, operationId, }: {
    endpointUrl: string;
    embeddedIFrameElement: HTMLIFrameElement;
    headers?: Record<string, string>;
    includeCookies?: boolean;
    introspectionRequestBody: string;
    embedUrl: string;
    handleRequest: HandleRequest;
    operationId: string;
}): Promise<void>;
export declare const handleAuthenticationPostMessage: ({ event, embeddedIFrameElement, embedUrl, }: {
    event: IncomingEmbedMessage;
    embeddedIFrameElement: HTMLIFrameElement;
    embedUrl: string;
}) => void;
export {};
